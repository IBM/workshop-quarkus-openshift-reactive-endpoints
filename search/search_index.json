{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Workshop: Reactive Endpoints with Quarkus on OpenShift \u00b6 In this workshop you'll learn how to implement reactive endpoints with Java, Quarkus and MicroProfile . An end-to-end sample application will be deployed to Red Hat OpenShift . The code is available as open source as part of the Cloud Native Starter project. One key benefit of reactive systems and reactive REST endpoints is efficiency. This workshop describes how to use reactive systems and reactive programming to achieve faster response times. Especially in public clouds where costs depend on CPU, RAM and compute durations this model saves money. The workshop uses a sample application to demonstrate reactive functionality. The sample application displays links to articles and author information. The sample contains a 'Web-API' service with two versions of the endpoint '/articles', one uses imperative code, the other one reactive code. In this workshop you'll re-implement a simplified version of the reactive version yourselves. The reactive stack of this sample provides response times that take less than half of the time compared to the imperative stack: Reactive Imperative 793 ms 1956 ms If you want to know more details, you can read the documentation of the performance tests. Architecture \u00b6 The following architecture diagrams do explain the complete flow the sample application. The 'API Client' invokes the 'Web-API' service which implements a backend-for-frontend pattern. The 'Web-API' service invokes the two microservices 'Authors' and 'Articles'. The 'Articles' service reads data from Postgres. Note that in this workshop you will deploy the full application as described in the previous diagram. But to simplify the workshop you'll re-implement a simpler version of the 'Web-API' service which only invokes the 'Articles' service. Estimated time and level \u00b6 Time Level one hour beginners Objectives \u00b6 After you complete this workshop, you'll understand the following reactive functionality: Reactive REST endpoints via CompletionStage Exception handling in chained reactive invocations Timeouts via CompletableFuture Reactive REST invocations via MicroProfile REST Client The intention of this workshop is not to explain every aspect of reactive programming, but to explain core reactive principles and to deploy a complete reactive application which you can inspect after the workshop in more detail. About this workshop \u00b6 The introductory page of the workshop is broken down into the following sections: Agenda Compatibility Technology Used Credits What`s next? Agenda \u00b6 These are the labs of this workshop, go through all of them in sequence, start with `Pre work: Pre work Create your Cloud Environment Deploy application Deploy the example application via script Exercise 1 Develop reactive Endpoints Exercise 2 Invoke Endpoints reactively Exercise 3 Deploy Service to OpenShift Exercise 4 Use distributed Logging Compatibility \u00b6 This workshop has been tested on the following platforms: IBM Open Shift : version 4.3 IBM Cloud Shell : beta Technology Used \u00b6 Jakarta EE MicroProfile Quarkus Apache Kafka PostgresSQL RedHat OpenShift Microservices architecture Vue.js Credits \u00b6 Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker Additional resources \u00b6 The blogs as well as the presentation describe the functionality in more detail. There is a second workshop which uses the same sample application. That workshop is called Reactive Messaging with Quarkus on OpenShift and it focusses on messaging with Kafka.","title":"About the workshop"},{"location":"#workshop-reactive-endpoints-with-quarkus-on-openshift","text":"In this workshop you'll learn how to implement reactive endpoints with Java, Quarkus and MicroProfile . An end-to-end sample application will be deployed to Red Hat OpenShift . The code is available as open source as part of the Cloud Native Starter project. One key benefit of reactive systems and reactive REST endpoints is efficiency. This workshop describes how to use reactive systems and reactive programming to achieve faster response times. Especially in public clouds where costs depend on CPU, RAM and compute durations this model saves money. The workshop uses a sample application to demonstrate reactive functionality. The sample application displays links to articles and author information. The sample contains a 'Web-API' service with two versions of the endpoint '/articles', one uses imperative code, the other one reactive code. In this workshop you'll re-implement a simplified version of the reactive version yourselves. The reactive stack of this sample provides response times that take less than half of the time compared to the imperative stack: Reactive Imperative 793 ms 1956 ms If you want to know more details, you can read the documentation of the performance tests.","title":"Workshop: Reactive Endpoints with Quarkus on OpenShift"},{"location":"#architecture","text":"The following architecture diagrams do explain the complete flow the sample application. The 'API Client' invokes the 'Web-API' service which implements a backend-for-frontend pattern. The 'Web-API' service invokes the two microservices 'Authors' and 'Articles'. The 'Articles' service reads data from Postgres. Note that in this workshop you will deploy the full application as described in the previous diagram. But to simplify the workshop you'll re-implement a simpler version of the 'Web-API' service which only invokes the 'Articles' service.","title":"Architecture"},{"location":"#estimated-time-and-level","text":"Time Level one hour beginners","title":"Estimated time and level"},{"location":"#objectives","text":"After you complete this workshop, you'll understand the following reactive functionality: Reactive REST endpoints via CompletionStage Exception handling in chained reactive invocations Timeouts via CompletableFuture Reactive REST invocations via MicroProfile REST Client The intention of this workshop is not to explain every aspect of reactive programming, but to explain core reactive principles and to deploy a complete reactive application which you can inspect after the workshop in more detail.","title":"Objectives"},{"location":"#about-this-workshop","text":"The introductory page of the workshop is broken down into the following sections: Agenda Compatibility Technology Used Credits What`s next?","title":"About this workshop"},{"location":"#agenda","text":"These are the labs of this workshop, go through all of them in sequence, start with `Pre work: Pre work Create your Cloud Environment Deploy application Deploy the example application via script Exercise 1 Develop reactive Endpoints Exercise 2 Invoke Endpoints reactively Exercise 3 Deploy Service to OpenShift Exercise 4 Use distributed Logging","title":"Agenda"},{"location":"#compatibility","text":"This workshop has been tested on the following platforms: IBM Open Shift : version 4.3 IBM Cloud Shell : beta","title":"Compatibility"},{"location":"#technology-used","text":"Jakarta EE MicroProfile Quarkus Apache Kafka PostgresSQL RedHat OpenShift Microservices architecture Vue.js","title":"Technology Used"},{"location":"#credits","text":"Niklas Heidloff Harald Uebele Thomas S\u00fcdbr\u00f6cker","title":"Credits"},{"location":"#additional-resources","text":"The blogs as well as the presentation describe the functionality in more detail. There is a second workshop which uses the same sample application. That workshop is called Reactive Messaging with Quarkus on OpenShift and it focusses on messaging with Kafka.","title":"Additional resources"},{"location":"SUMMARY/","text":"Summary \u00b6 Setup the IBM Cloud Environment \u00b6 Overview Access the Cluster Access IBM Cloud Shell Setup the sample application \u00b6 Exercise 1 - Deploy the example application via one script YouTube - How to setup the sample application (optional) Build a new version of the Microservice \u00b6 Exercise 1 - Develop reactive Endpoints Exercise 2 - Invoke Endpoints reactively Exercise 3 - Deploy Service to OpenShift Exercise 4 (optional) - Use distributed Logging YouTube Videos related to the Exercises \u00b6 Exercise 1 - Develop reactive Endpoints (optional) Exercise 2 - Invoke Endpoints reactively (optional) Exercise 3 - Deploy Service to OpenShift (optional) Exercise 4 - Use distributed Logging (optional) Additional Resources \u00b6 Blog posts related to reactive Workshop: Reactive Messaging with Quarkus on OpenShift Cloud-Native-Starter project Cloud-Native-Starter project reactive Known Issues \u00b6 Quarkus needs Apache Maven 3.6.2+","title":"Summary"},{"location":"SUMMARY/#summary","text":"","title":"Summary"},{"location":"SUMMARY/#setup-the-ibm-cloud-environment","text":"Overview Access the Cluster Access IBM Cloud Shell","title":"Setup the IBM Cloud Environment"},{"location":"SUMMARY/#setup-the-sample-application","text":"Exercise 1 - Deploy the example application via one script YouTube - How to setup the sample application (optional)","title":"Setup the sample application"},{"location":"SUMMARY/#build-a-new-version-of-the-microservice","text":"Exercise 1 - Develop reactive Endpoints Exercise 2 - Invoke Endpoints reactively Exercise 3 - Deploy Service to OpenShift Exercise 4 (optional) - Use distributed Logging","title":"Build a new version of the Microservice"},{"location":"SUMMARY/#youtube-videos-related-to-the-exercises","text":"Exercise 1 - Develop reactive Endpoints (optional) Exercise 2 - Invoke Endpoints reactively (optional) Exercise 3 - Deploy Service to OpenShift (optional) Exercise 4 - Use distributed Logging (optional)","title":"YouTube Videos related to the Exercises"},{"location":"SUMMARY/#additional-resources","text":"Blog posts related to reactive Workshop: Reactive Messaging with Quarkus on OpenShift Cloud-Native-Starter project Cloud-Native-Starter project reactive","title":"Additional Resources"},{"location":"SUMMARY/#known-issues","text":"Quarkus needs Apache Maven 3.6.2+","title":"Known Issues"},{"location":"exercise-01/","text":"Exercise 1: Deploy the example application via script \u00b6 In this short exercise you'll deploy Kafka, PostgreSQL, and the Microservices of the reactive example via a script and test the example application. Step 1: Deploy the example application \u00b6 Invoke the following command: bash ~/cloud-native-starter/reactive/os4-scripts/deploy-example.sh The deployment takes approximately 10 minutes . The script console output shows links to the Microservices and the Web-App at the end of the execution. The following 35 sec YouTube video shows a example execution of the script and the test of the application. Step 2: Launch the web application \u00b6 To launch the web application get the URL from the last output and open the application in a browser. Step 3: Copy the curl command \u00b6 Copy the curl command to create a new article and insert it into your current terminal session. Step 4: Test the example application \u00b6 Open the web application in a browser. Then invoke the curl post command. The web application should show the new entry. Step 5 (optional): Verify the deployed PostgreSQL \u00b6 You can check the status via the OpenShift web console. On the 'Pods' page select the 'postgres' project. Step 6 (optional): Verify the deployed Kafka \u00b6 You can check the status via the OpenShift web console. On the 'Pods' page select the 'kafka' project. Step 7 (optional): Verify the deployed Services and Web Application \u00b6 Make sure all four pods in the 'cloud-native-starter' project are running. The previous steps have create build configs, builds and image streams.","title":"Lab 0. Deploy the Application"},{"location":"exercise-01/#exercise-1-deploy-the-example-application-via-script","text":"In this short exercise you'll deploy Kafka, PostgreSQL, and the Microservices of the reactive example via a script and test the example application.","title":"Exercise 1: Deploy the example application via script"},{"location":"exercise-01/#step-1-deploy-the-example-application","text":"Invoke the following command: bash ~/cloud-native-starter/reactive/os4-scripts/deploy-example.sh The deployment takes approximately 10 minutes . The script console output shows links to the Microservices and the Web-App at the end of the execution. The following 35 sec YouTube video shows a example execution of the script and the test of the application.","title":"Step 1: Deploy the example application"},{"location":"exercise-01/#step-2-launch-the-web-application","text":"To launch the web application get the URL from the last output and open the application in a browser.","title":"Step 2: Launch the web application"},{"location":"exercise-01/#step-3-copy-the-curl-command","text":"Copy the curl command to create a new article and insert it into your current terminal session.","title":"Step 3: Copy the curl command"},{"location":"exercise-01/#step-4-test-the-example-application","text":"Open the web application in a browser. Then invoke the curl post command. The web application should show the new entry.","title":"Step 4: Test the example application"},{"location":"exercise-01/#step-5-optional-verify-the-deployed-postgresql","text":"You can check the status via the OpenShift web console. On the 'Pods' page select the 'postgres' project.","title":"Step 5 (optional): Verify the deployed PostgreSQL"},{"location":"exercise-01/#step-6-optional-verify-the-deployed-kafka","text":"You can check the status via the OpenShift web console. On the 'Pods' page select the 'kafka' project.","title":"Step 6 (optional): Verify the deployed Kafka"},{"location":"exercise-01/#step-7-optional-verify-the-deployed-services-and-web-application","text":"Make sure all four pods in the 'cloud-native-starter' project are running. The previous steps have create build configs, builds and image streams.","title":"Step 7 (optional): Verify the deployed Services and Web Application"},{"location":"exercise-02/","text":"Exercise 1: Develop reactive Endpoints \u00b6 In this exercise you will learn how to develop reactive endpoints with standard Java functionality via CompletionStage and CompletableFuture . The service that will be created is an easier implementation of the 'Web-API' service as described earlier. In this exercise the service only returns some dummy data and doesn't invoke other services. Step 1: Create Quarkus Project \u00b6 Let's start by creating a new Quarkus project with a synchronous REST endpoint. Invoke the following command the Cloud Shell. See Known Issues with Quarkus cd ~/cloud-native-starter/reactive mvn io.quarkus:quarkus-maven-plugin:1.7.0.Final:create \\ -DprojectGroupId = org.acme \\ -DprojectArtifactId = rest-json-quickstart \\ -DclassName = \"org.acme.rest.json.FruitResource\" \\ -Dpath = \"/fruits\" \\ -Dextensions = \"resteasy-jsonb\" To better understand which files have been created, run the same command locally and explore the generated code via the editor of your choice. Step 2: Test the synchronous Endpoint \u00b6 In order to test the synchronous endpoint which has been created with the command above, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/fruits You should see the following response. The implementation of the synchronous endpoint is in the class FruitResource.java . The annotations @Path, @Get and @Produces are used to define the endpoint via JAX-RS . To learn more about synchronous endpoints, check out the Quarkus guide . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ cat FruitResource.java Step 3: Create Classes Article and ArticleResource \u00b6 Next let's create a reactive endpoint. We need a new class 'ArticleResource.java' and a class 'Article.java' . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch Article.java touch ArticleResource.java nano Article.java Add the following code to 'Article.java' . package org.acme.rest.json ; public class Article { public String title ; public String url ; public String author ; public String id ; public String creationDate ; } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Modify the ArticleResource class via nano and add the following skeleton. The complete source is in the GitHub repo . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ nano ArticleResource.java package org.acme.rest.json ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; import javax.inject.Inject ; import javax.json.JsonArray ; import javax.json.stream.JsonCollectors ; import javax.ws.rs.core.Response ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.CompletionStage ; import javax.json.Json ; import javax.json.JsonObject ; import java.util.ArrayList ; @Path ( \"/articles\" ) public class ArticleResource { @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } static public List < Article > getSampleArticles () { ArrayList < Article > articles = new ArrayList < Article > (); Article article = new Article (); article . author = \"Niklas Heidloff\" ; article . title = \"Super awesome article\" ; article . url = \"http://heidloff.net\" ; article . id = \"1\" ; article . creationDate = new java . util . Date (). toString (); articles . add ( article ); return articles ; } static public JsonObject createJsonArticle ( Article article ) { return Json . createObjectBuilder () . add ( \"id\" , article . id ) . add ( \"title\" , article . title ) . add ( \"url\" , article . url ) . add ( \"author\" , article . author ) . build (); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Step 4: Test the reactive Endpoint \u00b6 In order to test the reactive endpoint, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/articles You should see the following response. Step 5: Understand the basic Implementation \u00b6 Now the big question is: How does the reactive endpoint work??? Let's go through the code line by line. Reactive endpoints use the same JAX-RS annotations '@Path' , '@Get' and '@Produces' as synchronous endpoints. @Path ( \"/articles\" ) public class ArticleResource { @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { The key difference is the return type. Rather than returning a Response object, a CompletionStage with a Response object is returned. The CompletionStage is returned immediately, so that the thread is not blocked. Only when it's completed, a callback is invoked which contains the actual response. To demonstrate this behavior better, a [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) instance is created and returned. CompletableFuture is an implementation of the CompletionStage instance. Once the asynchronous code has been completed, a method 'complete' is invoked on the CompletableFuture object. The static method 'CompletableFuture.supplyAsync()'` returns a list of sample articles asynchronously for demo purposes. In this case only one sample article is returned. public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { ... }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } The CompletionStage interface has several methods. Most of them return CompletionStages again. This allows chaining method invocations as done in the sample code. As input parameters functions are passed in via [Java Lambda](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html) . The method 'whenComplete' is triggered after the asynchronous methods have been completed. Another method of CompletionStage is 'thenApply' . This method is invoked after the previous asynchronous methods have been completed. The method can be used, for example, to convert data. In the sample code the list of articles is converted in two steps. First the list of article is converted into a JSON array and then the array is converted into a Response object. The methods 'stream' and 'map' are only used for the conversion and not related to reactive programming. public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } Step 6: Understand Exception Handling \u00b6 In the same way exceptions and errors can occur for synchronous code, they can happen for asychronous code as well. However the way to handle them is quite different. When invoking asynchronous methods exceptions cannot be handled via 'catch' as usual. Instead the method 'exceptionally' of the interface CompletionStage is used. The code below should give you an idea how to handle exceptions. To find out more, read the blog Chained asynchronous Invocations and Error Handling . If you want to try out 'exceptionally' uncomment the line where the InvalidInputParameter exception is thrown. @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); //if (true) throw new InvalidInputParameter(); return Response . ok ( articlesAsJson ). build (); }). exceptionally ( throwable -> { if ( throwable . getCause (). toString (). equals ( InvalidInputParameter . class . getName ())) return Response . status ( Response . Status . BAD_REQUEST ). build (); return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; }","title":"Lab 1. Develop Reactive Endpoints"},{"location":"exercise-02/#exercise-1-develop-reactive-endpoints","text":"In this exercise you will learn how to develop reactive endpoints with standard Java functionality via CompletionStage and CompletableFuture . The service that will be created is an easier implementation of the 'Web-API' service as described earlier. In this exercise the service only returns some dummy data and doesn't invoke other services.","title":"Exercise 1: Develop reactive Endpoints"},{"location":"exercise-02/#step-1-create-quarkus-project","text":"Let's start by creating a new Quarkus project with a synchronous REST endpoint. Invoke the following command the Cloud Shell. See Known Issues with Quarkus cd ~/cloud-native-starter/reactive mvn io.quarkus:quarkus-maven-plugin:1.7.0.Final:create \\ -DprojectGroupId = org.acme \\ -DprojectArtifactId = rest-json-quickstart \\ -DclassName = \"org.acme.rest.json.FruitResource\" \\ -Dpath = \"/fruits\" \\ -Dextensions = \"resteasy-jsonb\" To better understand which files have been created, run the same command locally and explore the generated code via the editor of your choice.","title":"Step 1: Create Quarkus Project"},{"location":"exercise-02/#step-2-test-the-synchronous-endpoint","text":"In order to test the synchronous endpoint which has been created with the command above, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/fruits You should see the following response. The implementation of the synchronous endpoint is in the class FruitResource.java . The annotations @Path, @Get and @Produces are used to define the endpoint via JAX-RS . To learn more about synchronous endpoints, check out the Quarkus guide . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ cat FruitResource.java","title":"Step 2: Test the synchronous Endpoint"},{"location":"exercise-02/#step-3-create-classes-article-and-articleresource","text":"Next let's create a reactive endpoint. We need a new class 'ArticleResource.java' and a class 'Article.java' . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch Article.java touch ArticleResource.java nano Article.java Add the following code to 'Article.java' . package org.acme.rest.json ; public class Article { public String title ; public String url ; public String author ; public String id ; public String creationDate ; } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Modify the ArticleResource class via nano and add the following skeleton. The complete source is in the GitHub repo . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ nano ArticleResource.java package org.acme.rest.json ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; import javax.inject.Inject ; import javax.json.JsonArray ; import javax.json.stream.JsonCollectors ; import javax.ws.rs.core.Response ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.CompletionStage ; import javax.json.Json ; import javax.json.JsonObject ; import java.util.ArrayList ; @Path ( \"/articles\" ) public class ArticleResource { @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } static public List < Article > getSampleArticles () { ArrayList < Article > articles = new ArrayList < Article > (); Article article = new Article (); article . author = \"Niklas Heidloff\" ; article . title = \"Super awesome article\" ; article . url = \"http://heidloff.net\" ; article . id = \"1\" ; article . creationDate = new java . util . Date (). toString (); articles . add ( article ); return articles ; } static public JsonObject createJsonArticle ( Article article ) { return Json . createObjectBuilder () . add ( \"id\" , article . id ) . add ( \"title\" , article . title ) . add ( \"url\" , article . url ) . add ( \"author\" , article . author ) . build (); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'.","title":"Step 3: Create Classes Article and ArticleResource"},{"location":"exercise-02/#step-4-test-the-reactive-endpoint","text":"In order to test the reactive endpoint, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/articles You should see the following response.","title":"Step 4: Test the reactive Endpoint"},{"location":"exercise-02/#step-5-understand-the-basic-implementation","text":"Now the big question is: How does the reactive endpoint work??? Let's go through the code line by line. Reactive endpoints use the same JAX-RS annotations '@Path' , '@Get' and '@Produces' as synchronous endpoints. @Path ( \"/articles\" ) public class ArticleResource { @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { The key difference is the return type. Rather than returning a Response object, a CompletionStage with a Response object is returned. The CompletionStage is returned immediately, so that the thread is not blocked. Only when it's completed, a callback is invoked which contains the actual response. To demonstrate this behavior better, a [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) instance is created and returned. CompletableFuture is an implementation of the CompletionStage instance. Once the asynchronous code has been completed, a method 'complete' is invoked on the CompletableFuture object. The static method 'CompletableFuture.supplyAsync()'` returns a list of sample articles asynchronously for demo purposes. In this case only one sample article is returned. public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { ... }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } The CompletionStage interface has several methods. Most of them return CompletionStages again. This allows chaining method invocations as done in the sample code. As input parameters functions are passed in via [Java Lambda](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html) . The method 'whenComplete' is triggered after the asynchronous methods have been completed. Another method of CompletionStage is 'thenApply' . This method is invoked after the previous asynchronous methods have been completed. The method can be used, for example, to convert data. In the sample code the list of articles is converted in two steps. First the list of article is converted into a JSON array and then the array is converted into a Response object. The methods 'stream' and 'map' are only used for the conversion and not related to reactive programming. public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; }","title":"Step 5: Understand the basic Implementation"},{"location":"exercise-02/#step-6-understand-exception-handling","text":"In the same way exceptions and errors can occur for synchronous code, they can happen for asychronous code as well. However the way to handle them is quite different. When invoking asynchronous methods exceptions cannot be handled via 'catch' as usual. Instead the method 'exceptionally' of the interface CompletionStage is used. The code below should give you an idea how to handle exceptions. To find out more, read the blog Chained asynchronous Invocations and Error Handling . If you want to try out 'exceptionally' uncomment the line where the InvalidInputParameter exception is thrown. @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); CompletableFuture . supplyAsync (() -> { List < Article > articles = getSampleArticles (); return articles ; }). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); //if (true) throw new InvalidInputParameter(); return Response . ok ( articlesAsJson ). build (); }). exceptionally ( throwable -> { if ( throwable . getCause (). toString (). equals ( InvalidInputParameter . class . getName ())) return Response . status ( Response . Status . BAD_REQUEST ). build (); return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; }","title":"Step 6: Understand Exception Handling"},{"location":"exercise-03/","text":"Exercise 2: Invoke Endpoints reactively \u00b6 In this exercise you will learn how to invoke REST APIs reactively with MicroProfile Rest Client . You will extend the service from the previous exercise to invoke the 'Articles' service which runs on OpenShift. Step 1: Add the MicroProfile Extension \u00b6 First the MicroProfile library needs to be added to the project. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw quarkus:add-extension -Dextensions = \"io.quarkus:quarkus-rest-client\" Step 2: Create Exception Handling Classes \u00b6 The great thing about the MicroProfile REST Client is that it makes it really easy to invoke remote APIs of other services. As developer you don't have to worry about serialization/deserialization/etc. All you need to do is to define interfaces and some configuration. In order to map HTTP response codes to Java exceptions, a ResponseExceptionMapper is used. Let's take a look. Create the class InvalidInputParameter.java . This exception is thrown by the 'Articles' service when the amount parameter is not correct, for example if the value is negative. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch InvalidInputParameter.java nano InvalidInputParameter.java package org.acme.rest.json ; public class InvalidInputParameter extends RuntimeException { private static final long serialVersionUID = 2L ; public InvalidInputParameter () { } public InvalidInputParameter ( String message ) { super ( message ); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Create the class ExceptionMapperArticles.java . In this class the HTTP response code '204' is mapped to the InvalidInputParameter exception. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ExceptionMapperArticles.java nano ExceptionMapperArticles.java package org.acme.rest.json ; import org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper ; import javax.ws.rs.core.MultivaluedMap ; import javax.ws.rs.core.Response ; import javax.ws.rs.ext.Provider ; @Provider public class ExceptionMapperArticles implements ResponseExceptionMapper < InvalidInputParameter > { @Override public boolean handles ( int status , MultivaluedMap < String , Object > headers ) { return status == 204 ; } @Override public InvalidInputParameter toThrowable ( Response response ) { if ( response . getStatus () == 204 ) return new InvalidInputParameter (); return null ; } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Step 3: Create the ArticlesService Interface \u00b6 Next an interface of the service that is supposed to be invoked is defined. The implementation of this interface is provided magically by MicroProfile. Create the class ArticlesService.java . To keep this as simple as possible, there is only one method to read a list of articles. Note that the annotations @Get and @Produces can be confusing. These are the JAX-RS annotations you used in the previous exercise. This time however they are not used to expose REST APIs, but to define how to invoke remote APIs. Also note that the service does not return a Response object directly. Instead it returns a CompletionStage object with a Response object as described earlier. With the MicroProfile Rest Client you can invoke services both synchronously as well as asynchronously. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ArticlesService.java nano ArticlesService.java package org.acme.rest.json ; import org.eclipse.microprofile.rest.client.annotation.RegisterProvider ; import javax.ws.rs.* ; import javax.ws.rs.core.MediaType ; import java.util.List ; import java.util.concurrent.CompletionStage ; @RegisterProvider ( ExceptionMapperArticles . class ) public interface ArticlesService { @GET @Produces ( MediaType . APPLICATION_JSON ) CompletionStage < List < Article >> getArticlesFromService ( @QueryParam ( \"amount\" ) int amount ); } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Step 4: Create the Code to invoke Services \u00b6 Now let's write the code to invoke the 'Articles' service. Basically all you need to do is to define the URL of the endpoint and invoke a Java method. Check out the code below, especially the invocation of the service via 'articlesService.getArticlesFromService(amount)'. Create the class ArticlesDataAccess.java . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ArticlesDataAccess.java nano ArticlesDataAccess.java package org.acme.rest.json ; import org.eclipse.microprofile.config.inject.ConfigProperty ; import org.eclipse.microprofile.rest.client.RestClientBuilder ; import javax.annotation.PostConstruct ; import javax.enterprise.context.ApplicationScoped ; import javax.ws.rs.core.UriBuilder ; import java.net.URI ; import java.util.List ; import java.util.concurrent.CompletionStage ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ArticlesDataAccess { private static final int MAXIMAL_DURATION = 5000 ; // this configuration needs to be used when running this web-api service locally // run the following command to get this URL: os4scripts/show-urls.sh private static String urlArticlesServiceOpenShift = \"http://articles-reactive-cloud-native-starter.niklas-heidloff-os-fra-162e406f043e20da9b0ef0731954a894-0000.eu-de.containers.appdomain.cloud/v2/articles?amount=10\" ; private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiUrl = UriBuilder . fromUri ( urlArticlesServiceOpenShift ). build (); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiUrl ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ); } } Open a second terminal session and run the following command to get the URL of your 'Articles' service. cd ~/cloud-native-starter/reactive os4-scripts/show-urls.sh Copy and paste the URL in the class ArticlesDataAccess you have open in your editor. Replace the value for the variable 'urlArticlesServiceOpenShift' with your copied value. ... private static String urlArticlesServiceOpenShift = \"YOUR-URL-VALUE\" ; ... Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Step 5: Modify the ArticleResource class \u00b6 In the last step you need to modify ArticleResource.java from the previous exercise to invoke the actual service rather than returning a sample article. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ rm ArticleResource.java touch ArticleResource.java nano ArticleResource.java package org.acme.rest.json ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; import javax.inject.Inject ; import javax.json.JsonArray ; import javax.json.stream.JsonCollectors ; import javax.ws.rs.core.Response ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.CompletionStage ; import javax.json.Json ; import javax.json.JsonObject ; import java.util.ArrayList ; @Path ( \"/articles\" ) public class ArticleResource { @Inject ArticlesDataAccess articlesDataAccess ; @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); articlesDataAccess . getArticlesReactive ( 10 ). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). exceptionally ( throwable -> { if ( throwable . getCause (). toString (). equals ( InvalidInputParameter . class . getName ())) return Response . status ( Response . Status . BAD_REQUEST ). build (); return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } static public List < Article > getSampleArticles () { ArrayList < Article > articles = new ArrayList < Article > (); Article article = new Article (); article . author = \"Niklas Heidloff\" ; article . title = \"Super awesome article\" ; article . url = \"http://heidloff.net\" ; article . id = \"1\" ; article . creationDate = new java . util . Date (). toString (); articles . add ( article ); return articles ; } static public JsonObject createJsonArticle ( Article article ) { return Json . createObjectBuilder () . add ( \"id\" , article . id ) . add ( \"title\" , article . title ) . add ( \"url\" , article . url ) . add ( \"author\" , article . author ) . build (); } } Step 6: Test the Code \u00b6 In order to test the reactive endpoint, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/articles You should see the following response. Step 7: Understand Timeouts \u00b6 When writing asynchronous code it's important to consider timeouts, especially when you invoke third party services like databases or other microservices. Fortunately starting with Java 9 this is easy to handle. When invoking the 'Articles' service via MicroProfile, you can use the method 'orTimeout' . If it comes to a timeout, an exception is thrown which you can handled via 'exceptionally' as explained in the last exercise. public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ) . toCompletableFuture () . orTimeout ( MAXIMAL_DURATION , TimeUnit . MILLISECONDS ); } The method 'orTimeout' doesn't exist in the CompletionStage interface. You need to run 'toCompletableFuture' first to get an instance of CompletableFuture. Unfortunately this capability is only available in Java 9+. Since the current version of the Cloud Shell supports only Java 8, we cannot run it here. But you can obviously run it locally or in a container on OpenShift.","title":"Lab 2. Invoke Endpoints Reactively"},{"location":"exercise-03/#exercise-2-invoke-endpoints-reactively","text":"In this exercise you will learn how to invoke REST APIs reactively with MicroProfile Rest Client . You will extend the service from the previous exercise to invoke the 'Articles' service which runs on OpenShift.","title":"Exercise 2: Invoke Endpoints reactively"},{"location":"exercise-03/#step-1-add-the-microprofile-extension","text":"First the MicroProfile library needs to be added to the project. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw quarkus:add-extension -Dextensions = \"io.quarkus:quarkus-rest-client\"","title":"Step 1: Add the MicroProfile Extension"},{"location":"exercise-03/#step-2-create-exception-handling-classes","text":"The great thing about the MicroProfile REST Client is that it makes it really easy to invoke remote APIs of other services. As developer you don't have to worry about serialization/deserialization/etc. All you need to do is to define interfaces and some configuration. In order to map HTTP response codes to Java exceptions, a ResponseExceptionMapper is used. Let's take a look. Create the class InvalidInputParameter.java . This exception is thrown by the 'Articles' service when the amount parameter is not correct, for example if the value is negative. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch InvalidInputParameter.java nano InvalidInputParameter.java package org.acme.rest.json ; public class InvalidInputParameter extends RuntimeException { private static final long serialVersionUID = 2L ; public InvalidInputParameter () { } public InvalidInputParameter ( String message ) { super ( message ); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Create the class ExceptionMapperArticles.java . In this class the HTTP response code '204' is mapped to the InvalidInputParameter exception. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ExceptionMapperArticles.java nano ExceptionMapperArticles.java package org.acme.rest.json ; import org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper ; import javax.ws.rs.core.MultivaluedMap ; import javax.ws.rs.core.Response ; import javax.ws.rs.ext.Provider ; @Provider public class ExceptionMapperArticles implements ResponseExceptionMapper < InvalidInputParameter > { @Override public boolean handles ( int status , MultivaluedMap < String , Object > headers ) { return status == 204 ; } @Override public InvalidInputParameter toThrowable ( Response response ) { if ( response . getStatus () == 204 ) return new InvalidInputParameter (); return null ; } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'.","title":"Step 2: Create Exception Handling Classes"},{"location":"exercise-03/#step-3-create-the-articlesservice-interface","text":"Next an interface of the service that is supposed to be invoked is defined. The implementation of this interface is provided magically by MicroProfile. Create the class ArticlesService.java . To keep this as simple as possible, there is only one method to read a list of articles. Note that the annotations @Get and @Produces can be confusing. These are the JAX-RS annotations you used in the previous exercise. This time however they are not used to expose REST APIs, but to define how to invoke remote APIs. Also note that the service does not return a Response object directly. Instead it returns a CompletionStage object with a Response object as described earlier. With the MicroProfile Rest Client you can invoke services both synchronously as well as asynchronously. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ArticlesService.java nano ArticlesService.java package org.acme.rest.json ; import org.eclipse.microprofile.rest.client.annotation.RegisterProvider ; import javax.ws.rs.* ; import javax.ws.rs.core.MediaType ; import java.util.List ; import java.util.concurrent.CompletionStage ; @RegisterProvider ( ExceptionMapperArticles . class ) public interface ArticlesService { @GET @Produces ( MediaType . APPLICATION_JSON ) CompletionStage < List < Article >> getArticlesFromService ( @QueryParam ( \"amount\" ) int amount ); } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'.","title":"Step 3: Create the ArticlesService Interface"},{"location":"exercise-03/#step-4-create-the-code-to-invoke-services","text":"Now let's write the code to invoke the 'Articles' service. Basically all you need to do is to define the URL of the endpoint and invoke a Java method. Check out the code below, especially the invocation of the service via 'articlesService.getArticlesFromService(amount)'. Create the class ArticlesDataAccess.java . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ touch ArticlesDataAccess.java nano ArticlesDataAccess.java package org.acme.rest.json ; import org.eclipse.microprofile.config.inject.ConfigProperty ; import org.eclipse.microprofile.rest.client.RestClientBuilder ; import javax.annotation.PostConstruct ; import javax.enterprise.context.ApplicationScoped ; import javax.ws.rs.core.UriBuilder ; import java.net.URI ; import java.util.List ; import java.util.concurrent.CompletionStage ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ArticlesDataAccess { private static final int MAXIMAL_DURATION = 5000 ; // this configuration needs to be used when running this web-api service locally // run the following command to get this URL: os4scripts/show-urls.sh private static String urlArticlesServiceOpenShift = \"http://articles-reactive-cloud-native-starter.niklas-heidloff-os-fra-162e406f043e20da9b0ef0731954a894-0000.eu-de.containers.appdomain.cloud/v2/articles?amount=10\" ; private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiUrl = UriBuilder . fromUri ( urlArticlesServiceOpenShift ). build (); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiUrl ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ); } } Open a second terminal session and run the following command to get the URL of your 'Articles' service. cd ~/cloud-native-starter/reactive os4-scripts/show-urls.sh Copy and paste the URL in the class ArticlesDataAccess you have open in your editor. Replace the value for the variable 'urlArticlesServiceOpenShift' with your copied value. ... private static String urlArticlesServiceOpenShift = \"YOUR-URL-VALUE\" ; ... Exit the Editor via 'Ctrl-X', 'y' and 'Enter'.","title":"Step 4: Create the Code to invoke Services"},{"location":"exercise-03/#step-5-modify-the-articleresource-class","text":"In the last step you need to modify ArticleResource.java from the previous exercise to invoke the actual service rather than returning a sample article. cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ rm ArticleResource.java touch ArticleResource.java nano ArticleResource.java package org.acme.rest.json ; import javax.ws.rs.GET ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; import javax.inject.Inject ; import javax.json.JsonArray ; import javax.json.stream.JsonCollectors ; import javax.ws.rs.core.Response ; import java.util.List ; import java.util.concurrent.CompletableFuture ; import java.util.concurrent.CompletionStage ; import javax.json.Json ; import javax.json.JsonObject ; import java.util.ArrayList ; @Path ( \"/articles\" ) public class ArticleResource { @Inject ArticlesDataAccess articlesDataAccess ; @GET @Produces ( MediaType . APPLICATION_JSON ) public CompletionStage < Response > getArticles () { CompletableFuture < Response > future = new CompletableFuture < Response > (); articlesDataAccess . getArticlesReactive ( 10 ). thenApply ( articles -> { JsonArray articlesAsJson ; articlesAsJson = articles . stream () . map ( article -> createJsonArticle ( article )) . collect ( JsonCollectors . toJsonArray ()); return Response . ok ( articlesAsJson ). build (); }). exceptionally ( throwable -> { if ( throwable . getCause (). toString (). equals ( InvalidInputParameter . class . getName ())) return Response . status ( Response . Status . BAD_REQUEST ). build (); return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ). build (); }). whenComplete (( response , e ) -> { future . complete ( response ); }); return future ; } static public List < Article > getSampleArticles () { ArrayList < Article > articles = new ArrayList < Article > (); Article article = new Article (); article . author = \"Niklas Heidloff\" ; article . title = \"Super awesome article\" ; article . url = \"http://heidloff.net\" ; article . id = \"1\" ; article . creationDate = new java . util . Date (). toString (); articles . add ( article ); return articles ; } static public JsonObject createJsonArticle ( Article article ) { return Json . createObjectBuilder () . add ( \"id\" , article . id ) . add ( \"title\" , article . title ) . add ( \"url\" , article . url ) . add ( \"author\" , article . author ) . build (); } }","title":"Step 5: Modify the ArticleResource class"},{"location":"exercise-03/#step-6-test-the-code","text":"In order to test the reactive endpoint, run these commands in one terminal in the Cloud Shell. cd ~/cloud-native-starter/reactive/rest-json-quickstart ./mvnw compile quarkus:dev Open a second terminal in the Cloud Shell and invoke the following command. curl http://localhost:8080/articles You should see the following response.","title":"Step 6: Test the Code"},{"location":"exercise-03/#step-7-understand-timeouts","text":"When writing asynchronous code it's important to consider timeouts, especially when you invoke third party services like databases or other microservices. Fortunately starting with Java 9 this is easy to handle. When invoking the 'Articles' service via MicroProfile, you can use the method 'orTimeout' . If it comes to a timeout, an exception is thrown which you can handled via 'exceptionally' as explained in the last exercise. public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ) . toCompletableFuture () . orTimeout ( MAXIMAL_DURATION , TimeUnit . MILLISECONDS ); } The method 'orTimeout' doesn't exist in the CompletionStage interface. You need to run 'toCompletableFuture' first to get an instance of CompletableFuture. Unfortunately this capability is only available in Java 9+. Since the current version of the Cloud Shell supports only Java 8, we cannot run it here. But you can obviously run it locally or in a container on OpenShift.","title":"Step 7: Understand Timeouts"},{"location":"exercise-04/","text":"Exercise 3: Deploy Service to OpenShift \u00b6 In this exercise you will deploy your 'My-Web-API' service to OpenShift. Step 1: Change the Endpoint URL \u00b6 Once the service is running on Kubernetes or OpenShift, it can access other services easily via DNS, for example in our case via http://articles-reactive:8080/ . In that case the traffic only occurs Re-create the class ArticlesDataAccess.java . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ rm ArticlesDataAccess.java touch ArticlesDataAccess.java nano ArticlesDataAccess.java package org.acme.rest.json ; import org.eclipse.microprofile.config.inject.ConfigProperty ; import org.eclipse.microprofile.rest.client.RestClientBuilder ; import javax.annotation.PostConstruct ; import javax.enterprise.context.ApplicationScoped ; import javax.ws.rs.core.UriBuilder ; import java.net.URI ; import java.util.List ; import java.util.concurrent.CompletionStage ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ArticlesDataAccess { private static final int MAXIMAL_DURATION = 5000 ; // this configuration needs to be used when running the code in OpenShift private static String urlArticlesServiceLocal = \"http://articles-reactive:8080/v2/articles?amount=10\" ; private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiUrl = UriBuilder . fromUri ( urlArticlesServiceLocal ). build (); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiUrl ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'. Step 2: Build the Image \u00b6 Invoke the following commands to build the image. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ oc project cloud-native-starter mvn package mv src/main/docker/Dockerfile.jvm ./Dockerfile oc new-build --name my-web-api-reactive --binary --strategy docker oc start-build my-web-api-reactive --from-dir = . The build will take some time. In the meantime you can check out the Dockerfile, for example to see how the ubi-minimal image is used. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ cat Dockerfile Open the OpenShift Web Console and wait for the build to be completed. The output of the build will be a new image stream. Step 3: Deploy and test the Image \u00b6 In the 'Developer' view, click on 'Add' and then 'Container Image'. On the next page choose 'Image from internal registry' and define the project, stream name and tag. Leave all other defaults including 'Create a route' and click 'Create'. On the next page click on 'my-web-api-reactive'. Wait until the pod is running. After this click on the route at the bottom. This will display the home page of the generated service. To invoke your endpoint append 'articles' to the URL.","title":"Lab 3. Deploy Service to OpenShift"},{"location":"exercise-04/#exercise-3-deploy-service-to-openshift","text":"In this exercise you will deploy your 'My-Web-API' service to OpenShift.","title":"Exercise 3: Deploy Service to OpenShift"},{"location":"exercise-04/#step-1-change-the-endpoint-url","text":"Once the service is running on Kubernetes or OpenShift, it can access other services easily via DNS, for example in our case via http://articles-reactive:8080/ . In that case the traffic only occurs Re-create the class ArticlesDataAccess.java . cd ~/cloud-native-starter/reactive/rest-json-quickstart/src/main/java/org/acme/rest/json/ rm ArticlesDataAccess.java touch ArticlesDataAccess.java nano ArticlesDataAccess.java package org.acme.rest.json ; import org.eclipse.microprofile.config.inject.ConfigProperty ; import org.eclipse.microprofile.rest.client.RestClientBuilder ; import javax.annotation.PostConstruct ; import javax.enterprise.context.ApplicationScoped ; import javax.ws.rs.core.UriBuilder ; import java.net.URI ; import java.util.List ; import java.util.concurrent.CompletionStage ; import java.util.concurrent.TimeUnit ; @ApplicationScoped public class ArticlesDataAccess { private static final int MAXIMAL_DURATION = 5000 ; // this configuration needs to be used when running the code in OpenShift private static String urlArticlesServiceLocal = \"http://articles-reactive:8080/v2/articles?amount=10\" ; private ArticlesService articlesService ; @PostConstruct void initialize () { URI apiUrl = UriBuilder . fromUri ( urlArticlesServiceLocal ). build (); articlesService = RestClientBuilder . newBuilder () . baseUri ( apiUrl ) . register ( ExceptionMapperArticles . class ) . build ( ArticlesService . class ); } public CompletionStage < List < Article >> getArticlesReactive ( int amount ) { return articlesService . getArticlesFromService ( amount ); } } Exit the Editor via 'Ctrl-X', 'y' and 'Enter'.","title":"Step 1: Change the Endpoint URL"},{"location":"exercise-04/#step-2-build-the-image","text":"Invoke the following commands to build the image. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ oc project cloud-native-starter mvn package mv src/main/docker/Dockerfile.jvm ./Dockerfile oc new-build --name my-web-api-reactive --binary --strategy docker oc start-build my-web-api-reactive --from-dir = . The build will take some time. In the meantime you can check out the Dockerfile, for example to see how the ubi-minimal image is used. cd ~/cloud-native-starter/reactive/rest-json-quickstart/ cat Dockerfile Open the OpenShift Web Console and wait for the build to be completed. The output of the build will be a new image stream.","title":"Step 2: Build the Image"},{"location":"exercise-04/#step-3-deploy-and-test-the-image","text":"In the 'Developer' view, click on 'Add' and then 'Container Image'. On the next page choose 'Image from internal registry' and define the project, stream name and tag. Leave all other defaults including 'Create a route' and click 'Create'. On the next page click on 'my-web-api-reactive'. Wait until the pod is running. After this click on the route at the bottom. This will display the home page of the generated service. To invoke your endpoint append 'articles' to the URL.","title":"Step 3: Deploy and test the Image"},{"location":"exercise-05/","text":"Exercise 4 (optional): Use distributed Logging \u00b6 Cloud native applications based on microservices contain many parts that create logs. A logging service that is able to collect all distributed logs in one place is a highly recommended tool. There are many logging solutions that you can install directly into your Kubernetes or OpenShift cluster. But then you have an additional application that needs to be maintained and one that needs persistent storage as well to store logs for a period of time. IBM Cloud offers \"Logging as a Service\" in the form of IBM Log Analysis with LogDNA . It offers features to filter, search, and tail log data, define alerts, and design custom views to monitor application and system logs. You can test \"IBM Log Analysis with LogDNA\" for free with somewhat limited capabilities and we will show you in this exercise how to connect your OpenShift cluster to an instance of it. Official documentation for setting up the LogDNA agent for an OpenShift cluster is here . For the following instructions use the IBM Cloud Shell to enter the commands. Step 1: Create LogDNA Service \u00b6 In your browser log in to the IBM Cloud dashboard . Make sure you are using your own account . From the 'burger menu' in the upper left corner select 'Observability'. Create an 'IBM Log Analysis with LogDNA' instance by clicking on 'Create new'. On the 'Create' tab leave all defaults. All you have to do is to create the big blue 'Create' button. Step 2: Configure LogDNA \u00b6 Select 'Edit log sources'. Select the 'OpenShift' tab. Copy, paste, and execute the commands into your IBM Cloud Shell: In the Cloud Shell check that the logging agent is running. oc get all -n ibm-observe Step 3: Use LogDNA \u00b6 Go back to the IBM Cloud dashboard . Make sure you are using your own account. From the 'burger menu' in the upper left corner select 'Observability' and then 'Logging'. Click 'View LogDNA'. In Exercise 1 Deploying Sample Application you have deployed an instance of the 'Articles' service called 'articles-reactive'. We will check LogDNA for output from this instance. Execute the following commands in the Cloud Shell: oc project cloud-native-starter watch curl -X GET \"http:// $( oc get route articles-reactive -o jsonpath ={ .spec.host } ) /v2/articles?amount=10\" -H \"accept: application/json\" The \"watch\" command will constantly (every 2 seconds) request articles information. Refresh your browser tab with the LogDNA dashboard and insert in the search field \"getArticlesReactive\" . Note: If you don't see \"getArticlesReactive\" wait a little longer (with the free/lite version it can take several minutes before data shows up), then refresh the browser tab of the LogDNA dashboard again. Select 'Unsaved View' and then 'Save as new/alert'. Give the view a ane and press 'Save View'. From now the new view is available under 'Views'. Congratulations! You\u2019ve finished the workshop!","title":"Lab 4. Use Ddistributed Logging"},{"location":"exercise-05/#exercise-4-optional-use-distributed-logging","text":"Cloud native applications based on microservices contain many parts that create logs. A logging service that is able to collect all distributed logs in one place is a highly recommended tool. There are many logging solutions that you can install directly into your Kubernetes or OpenShift cluster. But then you have an additional application that needs to be maintained and one that needs persistent storage as well to store logs for a period of time. IBM Cloud offers \"Logging as a Service\" in the form of IBM Log Analysis with LogDNA . It offers features to filter, search, and tail log data, define alerts, and design custom views to monitor application and system logs. You can test \"IBM Log Analysis with LogDNA\" for free with somewhat limited capabilities and we will show you in this exercise how to connect your OpenShift cluster to an instance of it. Official documentation for setting up the LogDNA agent for an OpenShift cluster is here . For the following instructions use the IBM Cloud Shell to enter the commands.","title":"Exercise 4 (optional): Use distributed Logging"},{"location":"exercise-05/#step-1-create-logdna-service","text":"In your browser log in to the IBM Cloud dashboard . Make sure you are using your own account . From the 'burger menu' in the upper left corner select 'Observability'. Create an 'IBM Log Analysis with LogDNA' instance by clicking on 'Create new'. On the 'Create' tab leave all defaults. All you have to do is to create the big blue 'Create' button.","title":"Step 1: Create LogDNA Service"},{"location":"exercise-05/#step-2-configure-logdna","text":"Select 'Edit log sources'. Select the 'OpenShift' tab. Copy, paste, and execute the commands into your IBM Cloud Shell: In the Cloud Shell check that the logging agent is running. oc get all -n ibm-observe","title":"Step 2: Configure LogDNA"},{"location":"exercise-05/#step-3-use-logdna","text":"Go back to the IBM Cloud dashboard . Make sure you are using your own account. From the 'burger menu' in the upper left corner select 'Observability' and then 'Logging'. Click 'View LogDNA'. In Exercise 1 Deploying Sample Application you have deployed an instance of the 'Articles' service called 'articles-reactive'. We will check LogDNA for output from this instance. Execute the following commands in the Cloud Shell: oc project cloud-native-starter watch curl -X GET \"http:// $( oc get route articles-reactive -o jsonpath ={ .spec.host } ) /v2/articles?amount=10\" -H \"accept: application/json\" The \"watch\" command will constantly (every 2 seconds) request articles information. Refresh your browser tab with the LogDNA dashboard and insert in the search field \"getArticlesReactive\" . Note: If you don't see \"getArticlesReactive\" wait a little longer (with the free/lite version it can take several minutes before data shows up), then refresh the browser tab of the LogDNA dashboard again. Select 'Unsaved View' and then 'Save as new/alert'. Give the view a ane and press 'Save View'. From now the new view is available under 'Views'. Congratulations! You\u2019ve finished the workshop!","title":"Step 3: Use LogDNA"},{"location":"known-issues/known-issues/","text":"Known Issues \u00b6 (2021/02/16) Quarkus needs Apache Maven 3.6.2+, which is not included in IBM Cloud Shell \u00b6 Thanks to Sbusiso Mkhombe and Karim Deif, because they pointed this out and documented the workaround for the Cloud Shell. Information in Quarkus Problem in IBM Cloud Shell Setup Maven in the IBM Cloud Shell \u00b6 So, in your cloud-native-starter/reactive directory you need to perform the following tasks: Step 1: Change to your reactive directory in your cloud-native-starter project. \u00b6 cd ~/cloud-native-starter/reactive Step 2: Download the latest mvn as a compressed file. \u00b6 wget https://downloads.apache.org/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz Step 3: Uncompress the Apache Maven file and create adirectory in the same location called apache-maven-3.6.3 \u00b6 tar -xvf apache-maven-3.6.3-bin.tar.gz Step 4: Add the mvn binary located in apache-maven-3.6.3/bin to the $PATH variable \u00b6 export PATH = ~/cloud-native-starter/reactive/apache-maven-3.6.3/bin: $PATH Step 5: Verify the used Maven version \u00b6 This should return a message that shows you are using mvn version like 3.6.3 mvn --version Continue with the execises as usual. Setup a local environment \u00b6 To run the development exercises can you also to setup following tools on your machine: git curl oc mvn Java 9 or higher or check out this Docker image which contains the actual tools.","title":"Known Issues"},{"location":"known-issues/known-issues/#known-issues","text":"","title":"Known Issues"},{"location":"known-issues/known-issues/#20210216-quarkus-needs-apache-maven-362-which-is-not-included-in-ibm-cloud-shell","text":"Thanks to Sbusiso Mkhombe and Karim Deif, because they pointed this out and documented the workaround for the Cloud Shell. Information in Quarkus Problem in IBM Cloud Shell","title":"(2021/02/16) Quarkus needs Apache Maven 3.6.2+, which is not included in IBM Cloud Shell"},{"location":"known-issues/known-issues/#setup-maven-in-the-ibm-cloud-shell","text":"So, in your cloud-native-starter/reactive directory you need to perform the following tasks:","title":"Setup Maven in the IBM Cloud Shell"},{"location":"known-issues/known-issues/#step-1-change-to-your-reactive-directory-in-your-cloud-native-starter-project","text":"cd ~/cloud-native-starter/reactive","title":"Step 1: Change to your reactive directory in your cloud-native-starter project."},{"location":"known-issues/known-issues/#step-2-download-the-latest-mvn-as-a-compressed-file","text":"wget https://downloads.apache.org/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz","title":"Step 2: Download the latest mvn as a compressed file."},{"location":"known-issues/known-issues/#step-3-uncompress-the-apache-maven-file-and-create-adirectory-in-the-same-location-called-apache-maven-363","text":"tar -xvf apache-maven-3.6.3-bin.tar.gz","title":"Step 3: Uncompress the Apache Maven file and create adirectory in the same location called apache-maven-3.6.3"},{"location":"known-issues/known-issues/#step-4-add-the-mvn-binary-located-in-apache-maven-363bin-to-the-path-variable","text":"export PATH = ~/cloud-native-starter/reactive/apache-maven-3.6.3/bin: $PATH","title":"Step 4: Add the mvn binary located in apache-maven-3.6.3/bin to the $PATH variable"},{"location":"known-issues/known-issues/#step-5-verify-the-used-maven-version","text":"This should return a message that shows you are using mvn version like 3.6.3 mvn --version Continue with the execises as usual.","title":"Step 5: Verify the used Maven version"},{"location":"known-issues/known-issues/#setup-a-local-environment","text":"To run the development exercises can you also to setup following tools on your machine: git curl oc mvn Java 9 or higher or check out this Docker image which contains the actual tools.","title":"Setup a local environment"},{"location":"pre-work/","text":"Overview: Create your Cloud Environment \u00b6 The main instructions of this workshop assume that you will use Red Hat OpenShift 4.3 on IBM Cloud. However you can also use CodeReady Containers to run OpenShift locally. To use OpenShift on IBM Cloud and LogDNA in exercise 4, an IBM Cloud account is needed. It's free, doesn't expire and for the lite account no credit card is required. We will use preconfigured OpenShift on IBM Cloud clusters in this hands-on workshop.","title":"Create your Cloud Environment"},{"location":"pre-work/#overview-create-your-cloud-environment","text":"The main instructions of this workshop assume that you will use Red Hat OpenShift 4.3 on IBM Cloud. However you can also use CodeReady Containers to run OpenShift locally. To use OpenShift on IBM Cloud and LogDNA in exercise 4, an IBM Cloud account is needed. It's free, doesn't expire and for the lite account no credit card is required. We will use preconfigured OpenShift on IBM Cloud clusters in this hands-on workshop.","title":"Overview: Create your Cloud Environment"},{"location":"pre-work/CLOUD_ACCOUNT/","text":"Access the Cluster \u00b6 In this section, you will login to your own IBM Cloud account, and then get access to a IBM Cloud Lab account which contains pre-provisioned clusters. Each workshop attendee will be granted access to one cluster. Step 1: Setting up your IBM Cloud ID \u00b6 Log into IBM Cloud with an existing account: https://cloud.ibm.com OR Create your own: http://ibm.biz/nheidloff Step 2: Accessing the Cluster \u00b6 Instructors will provide a URL to a web app. Enter your IBMid (the email you used to sign up) and the workshop key (also provided by the instructor). Follow the instructions on the next page. You will be added to the IBM Workshop account and granted access to a cluster. Note the name of your cluster. In the example below, it's TorontoMulticlientWorkshop31 . Back in IBM Cloud, refresh the IBM Cloud Dashboard . If required, switch to the 1840867-IBM account by clicking on the account selection drop down in the top nav bar. Click on Clusters in the Resource Summary tile. Under Clusters , click on the cluster that has been assigned to you. ![cluster-overviewcluster-overview.png) Launch the OpenShift web console and have a look around! You can come back to this dashboard throughout your workshop.","title":"Access the Cluster"},{"location":"pre-work/CLOUD_ACCOUNT/#access-the-cluster","text":"In this section, you will login to your own IBM Cloud account, and then get access to a IBM Cloud Lab account which contains pre-provisioned clusters. Each workshop attendee will be granted access to one cluster.","title":"Access the Cluster"},{"location":"pre-work/CLOUD_ACCOUNT/#step-1-setting-up-your-ibm-cloud-id","text":"Log into IBM Cloud with an existing account: https://cloud.ibm.com OR Create your own: http://ibm.biz/nheidloff","title":"Step 1: Setting up your IBM Cloud ID"},{"location":"pre-work/CLOUD_ACCOUNT/#step-2-accessing-the-cluster","text":"Instructors will provide a URL to a web app. Enter your IBMid (the email you used to sign up) and the workshop key (also provided by the instructor). Follow the instructions on the next page. You will be added to the IBM Workshop account and granted access to a cluster. Note the name of your cluster. In the example below, it's TorontoMulticlientWorkshop31 . Back in IBM Cloud, refresh the IBM Cloud Dashboard . If required, switch to the 1840867-IBM account by clicking on the account selection drop down in the top nav bar. Click on Clusters in the Resource Summary tile. Under Clusters , click on the cluster that has been assigned to you. ![cluster-overviewcluster-overview.png) Launch the OpenShift web console and have a look around! You can come back to this dashboard throughout your workshop.","title":"Step 2: Accessing the Cluster"},{"location":"pre-work/CLOUD_SHELL/","text":"IBM Cloud Shell \u00b6 For this workshop we'll be using the IBM Cloud Shell. The IBM Cloud Shell is a cloud-based shell workspace that you can access through your browser. It's preconfigured with the full IBM Cloud CLI and other 3 rd party CLIs like OpenShift's oc , Helm's helm and Kubernetes' kubectl . Step 1: Set up Terminal \u00b6 When using OpenShift on IBM Cloud no client side setup is required for this workshop. Instead we will use the IBM Cloud Shell (Beta) which comes with all necessary CLIs (command line tools). In your browser, login to the IBM Cloud Dashboard. Make sure you select your own account in the account list at the top, then click on the IBM Cloud Shell icon. Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 30-hour weekly usage limit, your workspace data is removed. This is what you should see: When using OpenShift locally, you need a local terminal and the following tools: git curl oc mvn Java 9 or higher Step 2: Get the Code \u00b6 In the IBM Cloud Shell execute the following command: git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/reactive ROOT_FOLDER = $( pwd ) Step 3. Get Access to OpenShift \u00b6 Open the IBM Cloud Dashboard . In the row at the top switch from your own account to the IBM account given to you by the instructor from the pulldown in the uper right corner. The select 'OpenShift' in the burger menu in the upper left corner followed by 'Clusters'. Click on your cluster. Open the OpenShift web console. From the dropdown menu in the upper right of the page, click 'Copy Login Command'. Click on 'Display Token', then copy and paste the command 'Log in with this token' into your terminal in the IBM Cloud Shell. Login to OpenShift in IBM Cloud Shell oc login https://c1XX-XX-X.containers.cloud.ibm.com:XXXXX --token = xxxxxx ' ![openshift-login3openshift-login3.png)","title":"Access IBM Cloud Shell"},{"location":"pre-work/CLOUD_SHELL/#ibm-cloud-shell","text":"For this workshop we'll be using the IBM Cloud Shell. The IBM Cloud Shell is a cloud-based shell workspace that you can access through your browser. It's preconfigured with the full IBM Cloud CLI and other 3 rd party CLIs like OpenShift's oc , Helm's helm and Kubernetes' kubectl .","title":"IBM Cloud Shell"},{"location":"pre-work/CLOUD_SHELL/#step-1-set-up-terminal","text":"When using OpenShift on IBM Cloud no client side setup is required for this workshop. Instead we will use the IBM Cloud Shell (Beta) which comes with all necessary CLIs (command line tools). In your browser, login to the IBM Cloud Dashboard. Make sure you select your own account in the account list at the top, then click on the IBM Cloud Shell icon. Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 30-hour weekly usage limit, your workspace data is removed. This is what you should see: When using OpenShift locally, you need a local terminal and the following tools: git curl oc mvn Java 9 or higher","title":"Step 1: Set up Terminal"},{"location":"pre-work/CLOUD_SHELL/#step-2-get-the-code","text":"In the IBM Cloud Shell execute the following command: git clone https://github.com/IBM/cloud-native-starter.git cd cloud-native-starter/reactive ROOT_FOLDER = $( pwd )","title":"Step 2: Get the Code"},{"location":"pre-work/CLOUD_SHELL/#step-3-get-access-to-openshift","text":"Open the IBM Cloud Dashboard . In the row at the top switch from your own account to the IBM account given to you by the instructor from the pulldown in the uper right corner. The select 'OpenShift' in the burger menu in the upper left corner followed by 'Clusters'. Click on your cluster. Open the OpenShift web console. From the dropdown menu in the upper right of the page, click 'Copy Login Command'. Click on 'Display Token', then copy and paste the command 'Log in with this token' into your terminal in the IBM Cloud Shell. Login to OpenShift in IBM Cloud Shell oc login https://c1XX-XX-X.containers.cloud.ibm.com:XXXXX --token = xxxxxx ' ![openshift-login3openshift-login3.png)","title":"Step 3. Get Access to OpenShift"}]}